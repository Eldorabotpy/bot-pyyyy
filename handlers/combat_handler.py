# handlers/combat_handler.py

import random
import math
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CallbackQueryHandler
from telegram.error import BadRequest
from modules import file_ids 
from modules import player_manager, game_data
from handlers.menu.region import send_region_menu
from handlers.utils import format_combat_message
from handlers.class_selection_handler import show_class_selection_menu
from modules import mission_manager
from modules import clan_manager

# üîó Integra√ß√£o com Dungeon (runtime novo)
try:
    from modules.dungeons.runtime import advance_after_victory as _dungeon_advance_after_victory
except Exception:
    _dungeon_advance_after_victory = None  # sem dungeon instalada


# -------------------------
# Helpers de seguran√ßa/UI
# -------------------------
async def _safe_answer(query):
    try:
        await query.answer()
    except BadRequest:
        pass


async def _edit_caption_only(query, caption_text: str, reply_markup=None):
    """Edita SEMPRE a CAPTION; se falhar, manda fallback como texto."""
    try:
        await query.edit_message_caption(
            caption=caption_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )
    except BadRequest:
        try:
            await query.get_bot().send_message(
                chat_id=query.message.chat_id,
                text=caption_text,
                reply_markup=reply_markup,
                parse_mode='HTML'
            )
        except Exception:
            pass


def _mstat(details: dict, key: str, default: int = 1) -> int:
    """L√™ stats do monstro aceitando tanto 'monster_attack' quanto 'attack' etc."""
    return int(details.get(f"monster_{key}", details.get(key, default)))


# -------------------------
# Durabilidade ‚Äî helpers
# -------------------------
_WEAPON_SLOTS = ("weapon", "primary_weapon", "arma")
_ARMOR_SLOTS  = ("elmo", "armadura", "calca", "luvas", "botas", "anel", "colar", "brinco")


def _get_equipped_uid(player_data: dict, slot_names) -> str | None:
    equip = (player_data or {}).get("equipment", {}) or {}
    for s in slot_names:
        uid = equip.get(s)
        if isinstance(uid, str) and uid:
            return uid
    return None


def _get_unique_inst(player_data: dict, uid: str) -> dict | None:
    if not uid:
        return None
    inv = (player_data or {}).get("inventory", {}) or {}
    inst = inv.get(uid)
    return inst if isinstance(inst, dict) and inst.get("base_id") else None


def _dur_tuple(raw) -> tuple[int, int]:
    cur, mx = 20, 20
    if isinstance(raw, (list, tuple)) and len(raw) >= 2:
        try:
            cur = int(raw[0]); mx = int(raw[1])
        except Exception:
            pass
    elif isinstance(raw, dict):
        try:
            cur = int(raw.get("current", 20)); mx = int(raw.get("max", 20))
        except Exception:
            pass
    cur = max(0, cur)
    mx = max(1, mx)
    if cur > mx:
        cur = mx
    return cur, mx


def _consume_durability(player_data: dict, uid: str, amount: int = 1) -> tuple[int, int, bool]:
    """
    Consome 'amount' de durabilidade do item √∫nico 'uid'.
    Retorna (cur, mx, quebrou_agora).
    """
    inv = player_data.get("inventory", {}) or {}
    inst = inv.get(uid)
    if not isinstance(inst, dict):
        return (0, 0, False)

    cur, mx = _dur_tuple(inst.get("durability"))
    if mx <= 0:
        mx = 20
    if cur <= 0:
        # j√° quebrado
        return (0, mx, False)

    cur = max(0, cur - int(amount))
    inst["durability"] = [cur, mx]
    inv[uid] = inst
    player_data["inventory"] = inv
    return (cur, mx, cur == 0)


def _weapon_broken(player_data: dict) -> tuple[bool, str | None, tuple[int, int]]:
    """Verifica se a arma equipada est√° quebrada (durabilidade 0)."""
    w_uid = _get_equipped_uid(player_data, _WEAPON_SLOTS)
    if not w_uid:
        return (False, None, (0, 0))
    inst = _get_unique_inst(player_data, w_uid)
    if not inst:
        return (False, None, (0, 0))
    cur, mx = _dur_tuple(inst.get("durability"))
    return (cur <= 0, w_uid, (cur, mx))


def _apply_end_of_battle_durability(player_data: dict, combat_details: dict, log: list[str]) -> None:
    """
    Consome durabilidade UMA √öNICA VEZ no fim da batalha:
      - arma -1 se used_weapon=True
      - TODAS AS PE√áAS DE ARMADURA -1 se took_damage=True
    Adiciona logs se quebrar.
    """
    used_weapon = bool(combat_details.get("used_weapon"))
    took_damage = bool(combat_details.get("took_damage"))
    changed = False
    user_id = player_data.get("user_id", 0)

    # 1. Desgaste da Arma (l√≥gica existente, sem altera√ß√µes)
    if used_weapon:
        w_uid = _get_equipped_uid(player_data, _WEAPON_SLOTS)
        if w_uid:
            cur, mx, broke_now = _consume_durability(player_data, w_uid, 1)
            changed = True
            if broke_now:
                log.append(
                    f"‚ö†Ô∏è ùë∫ùíñùíÇ ùíÇùíìùíéùíÇ ùííùíñùíÜùíÉùíìùíêùíñ ({cur}/{mx}). "
                    f"ùëºùíîùíÜ üìú ùë∑ùíÜùíìùíàùíÇùíéùíäùíèùíâùíê ùíÖùíÜ ùë´ùíñùíìùíÇùíÉùíäùíçùíäùíÖùíÇùíÖùíÜ ùíëùíÇùíìùíÇ ùíìùíÜùíîùíïùíÇùíñùíìùíÇùíì."
                )

    # ###############################################################
    # ## IN√çCIO DA L√ìGICA ATUALIZADA (DESGASTE EM TODOS) ##
    # ###############################################################
    if took_damage:
        # Encontra todas as pe√ßas de armadura e acess√≥rios equipados
        equipped_armor_uids = []
        for slot in _ARMOR_SLOTS:
            uid = _get_equipped_uid(player_data, [slot])
            if uid:
                equipped_armor_uids.append(uid)
        
        # Se houver pelo menos uma pe√ßa...
        if equipped_armor_uids:
            # NOVO: Loop que passa por CADA item encontrado
            for uid_to_damage in equipped_armor_uids:
                cur, mx, broke_now = _consume_durability(player_data, uid_to_damage, 1)
                changed = True
                
                if broke_now:
                    # Pega o nome do item para uma mensagem mais clara
                    item_inst = _get_unique_inst(player_data, uid_to_damage)
                    item_name = (item_inst or {}).get("display_name", "Sua armadura")
                    log.append(
                        f"‚ö†Ô∏è {item_name} ùííùíñùíÜùíÉùíìùíêùíñ ({cur}/{mx}). "
                        f"ùëºùíîùíÜ üìú ùë∑ùíÜùíìùíàùíÇùíéùíäùíèùíâùíê ùíÖùíÜ ùë´ùíñùíìùíÇùíÉùíäùíçùíäùíÖùíÇùíÖùíÜ ùíëùíÇùíìùíÇ ùíìùíÜùíîùíïùíÇùíñùíìùíÇùíì."
                    )
    # ###############################################################
    # ## FIM DA L√ìGICA ATUALIZADA ##
    # ###############################################################

    # Salva os dados se alguma durabilidade foi alterada
    if changed:
        player_manager.save_player_data(user_id, player_data)

    # Limpa as flags para a pr√≥xima batalha
    combat_details.pop("used_weapon", None)
    combat_details.pop("took_damage", None)

# -------------------------
# Cr√≠ticos ‚Äî helpers
# -------------------------
def _clamp(v: float, lo: float, hi: float) -> float:
    return max(lo, min(hi, v))


def _diminishing_crit_chance_from_luck(luck: int) -> float:
    """
    Retorno decrescente: 100 * (1 - 0.99**luck)
    Ex.: Luck 10 ‚âà 9.6%, Luck 30 ‚âà 25.9%, Luck 50 ‚âà 39.5%
    """
    try:
        l = max(0, int(luck))
    except Exception:
        l = 0
    return 100.0 * (1.0 - (0.99 ** l))


def _get_player_class_key(pdata: dict) -> str | None:
    # Vers√£o local do normalizador
    def _as_dict(obj):
        return obj if isinstance(obj, dict) else {}
    candidates = [
        _as_dict(pdata.get("class")).get("type"),
        _as_dict(pdata.get("classe")).get("type"),
        pdata.get("class_type"),
        pdata.get("classe_tipo"),
        pdata.get("class_key"),
        pdata.get("classe"),
        pdata.get("class"),
    ]
    for c in candidates:
        if isinstance(c, str) and c.strip():
            return c.strip().lower()
    return None


def _crit_params_for_player(player_data: dict) -> dict:
    luck = int(player_manager.get_player_total_stats(player_data).get("luck", 5))

    chance = _diminishing_crit_chance_from_luck(luck)
    chance = _clamp(chance, 1.0, 40.0)

    mega_chance = min(25.0, luck / 2.0)
    mult = 1.6
    mega_mult = 2.0

    ckey = _get_player_class_key(player_data) or ""
    if ckey == "assassino":
        chance = min(45.0, chance + 5.0)
        mult = 1.6
        mega_mult = 2.1
    elif ckey == "guerreiro":
        mult = 1.7
        mega_mult = 2.0
    elif ckey == "mago":
        mult = 1.6
        mega_mult = 2.2
        mega_chance = min(30.0, mega_chance + 3.0)

    return {
        "chance": chance,
        "mega_chance": mega_chance,
        "mult": mult,
        "mega_mult": mega_mult,
        "min_damage": 1,
    }


def _crit_params_for_monster(details: dict) -> dict:
    luck = _mstat(details, 'luck', 5)
    chance = _diminishing_crit_chance_from_luck(luck)
    chance = _clamp(chance, 1.0, 30.0)

    mega_chance = min(15.0, luck / 3.0)
    mult = 1.5
    mega_mult = 1.75

    return {
        "chance": chance,
        "mega_chance": mega_chance,
        "mult": mult,
        "mega_mult": mega_mult,
        "min_damage": 1,
    }


def _roll_crit_and_damage(raw_attack: int, target_defense: int, params: dict) -> tuple[int, bool, bool]:
    """
    Aplica cr√≠tico ANTES da defesa, arredondando para cima.
    Retorna (final_damage, crit, mega).
    """
    r = random.random() * 100.0
    is_crit = (r <= float(params.get("chance", 0.0)))

    mult = 1.0
    mega = False
    if is_crit:
        r2 = random.random() * 100.0
        if r2 <= float(params.get("mega_chance", 0.0)):
            mult = float(params.get("mega_mult", 2.0))
            mega = True
        else:
            mult = float(params.get("mult", 1.6))

    boosted = math.ceil(float(raw_attack) * mult)
    dmg = max(int(params.get("min_damage", 1)), boosted - int(target_defense))
    return dmg, is_crit, mega


# --- penalidade de XP na derrota ---
def _apply_defeat_xp_penalty(player_data: dict, combat_details: dict) -> int:
    """
    Penaliza XP ao perder a batalha, EXCETO na floresta_sombria.
    """
    region_da_batalha = (combat_details or {}).get("region_key")
    if region_da_batalha == "floresta_sombria":
        return 0 # Retorna 0 de XP perdido, efetivamente cancelando a penalidade

    # A l√≥gica original continua para todas as outras regi√µes
    base_reward = int(combat_details.get('monster_xp_reward', 0))
    loss = max(0, base_reward * 2)
    cur = int(player_data.get('xp', 0))
    new_xp = max(0, cur - loss)
    player_data['xp'] = new_xp
    return loss


# -------------------------
# Voltar ao menu da regi√£o
# -------------------------
async def _return_to_region_menu(context: ContextTypes.DEFAULT_TYPE, user_id: int, chat_id: int, msg: str | None = None):
    """Sai do combate, seta idle e mostra o menu da regi√£o atual."""
    player = player_manager.get_player_data(user_id) or {}
    player['player_state'] = {'action': 'idle'}
    player_manager.save_player_data(user_id, player)

    if msg:
        await context.bot.send_message(chat_id, msg)

    await send_region_menu(context=context, user_id=user_id, chat_id=chat_id)


def _is_dungeon_battle(details: dict) -> bool:
    """Detecta se este combate pertence a uma run de dungeon."""
    return bool(details.get("dungeon_ctx") or details.get("dungeon_run") or details.get("dungeon_next_on_victory"))


# -------------------------
# Handler principal
# -------------------------
# Em handlers/combat_handler.py

async def combat_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Manipula as a√ß√µes de combate: atacar ou fugir (UI sempre como V√çDEO/FOTO -> edit caption)."""
    query = update.callback_query
    await _safe_answer(query)

    user_id = query.from_user.id
    chat_id = query.message.chat_id

    player_data = player_manager.get_player_data(user_id)
    if not player_data:
        try:
            await query.edit_message_caption(caption="N√£o encontrei seus dados. Use /start para come√ßar.")
        except BadRequest:
            await context.bot.send_message(chat_id=chat_id, text="N√£o encontrei seus dados. Use /start para come√ßar.")
        return

    player_data["user_id"] = user_id

    state = player_data.get('player_state', {})
    if state.get('action') != 'in_combat':
        try:
            await query.edit_message_caption(caption="Voc√™ n√£o est√° em combate no momento.")
        except BadRequest:
            await context.bot.send_message(chat_id=chat_id, text="Voc√™ n√£o est√° em combate no momento.")
        return

    combat_details = dict(state.get('details', {}) or {})

    if 'monster_max_hp' not in combat_details:
        try:
            combat_details['monster_max_hp'] = int(combat_details.get('monster_hp', 1))
            player_data['player_state']['details'] = combat_details
            player_manager.save_player_data(user_id, player_data)
        except Exception:
            pass

    player_total_stats = player_manager.get_player_total_stats(player_data)
    log = list(combat_details.get('battle_log', []))

    action = query.data
    in_dungeon = _is_dungeon_battle(combat_details)

    # =============================
    # FUGA
    # =============================
    if action == 'combat_flee':
        player_ini = int(player_total_stats.get('initiative', 10))
        monster_ini = _mstat(combat_details, 'initiative', 5)
        bias = float(combat_details.get("flee_bias", 0.0))
        flee_chance = max(0.05, min(0.95, 0.75 + ((player_ini - monster_ini) / 100.0) + bias))

        if random.random() <= flee_chance:
            _apply_end_of_battle_durability(player_data, combat_details, log)

            try:
                await query.delete_message()
            except Exception:
                pass

            if in_dungeon:
                player_data['player_state'] = {'action': 'idle'}
                player_manager.save_player_data(user_id, player_data)
                await _return_to_region_menu(context, user_id, chat_id, "üèÉ Voc√™ fugiu do calabou√ßo.")
                return

            await _return_to_region_menu(context, user_id, chat_id, "üèÉ ùëΩùíêùíÑùíÜÃÇ ùíÑùíêùíèùíîùíÜùíàùíñùíäùíñ ùíáùíñùíàùíäùíì ùíÖùíÇ ùíÉùíÇùíïùíÇùíçùíâùíÇ.")
            return
        else:
            log.append("üèÉ ùë∫ùíñùíÇ ùíïùíÜùíèùíïùíÇùíïùíäùíóùíÇ ùíÖùíÜ ùíáùíñùíàùíÇ ùíáùíÇùíçùíâùíêùíñ!")

            dodge_chance = player_manager.get_player_dodge_chance(player_data)
            if random.random() < dodge_chance:
                log.append(f"‚ö°Ô∏è Mas com um movimento √°gil, voc√™ se **esquivou** do ataque do inimigo!")
            else:
                monster_attack = _mstat(combat_details, 'attack', 1)
                player_defense = int(player_total_stats.get('defense', 3))
                mparams = _crit_params_for_monster(combat_details)
                monster_damage, mcrit, mmega = _roll_crit_and_damage(monster_attack, player_defense, mparams)

                if mcrit and mmega: log.append("‚ò†Ô∏è ùêåùêÑùêÜùêÄ ùêÇùêëùêàÃÅùêìùêàùêÇùêé ùêÉùêé ùêàùêçùêàùêåùêàùêÜùêé! ‚ò†Ô∏è")
                elif mcrit: log.append("üíÄ ùêÇùêëùêàÃÅùêìùêàùêÇùêé ùêÉùêé ùêàùêçùêàùêåùêàùêÜùêé! üíÄ")

                combat_details["took_damage"] = True
                player_data['current_hp'] = int(player_data.get('current_hp', 0)) - monster_damage
                log.append(f"‚¨ÖÔ∏è {combat_details.get('monster_name','Inimigo')} ùíÇùíïùíÇùíÑùíÇ!")
                log.append(f"ü©∏ ùëΩùíêùíÑùíÜÃÇ ùíìùíÜùíÑùíÜùíÉùíÜ {monster_damage} ùíÖùíÜ ùíÖùíÇùíèùíê.")

            if player_data['current_hp'] <= 0:
                xp_lost = _apply_defeat_xp_penalty(player_data, combat_details)
                _apply_end_of_battle_durability(player_data, combat_details, log)
                player_data['current_hp'] = int(player_manager.get_player_total_stats(player_data).get('max_hp', 50))
                player_data['player_state'] = {'action': 'idle'}
                player_manager.save_player_data(user_id, player_data)

                try:
                    await query.delete_message()
                except Exception:
                    pass

                if in_dungeon:
                    await _return_to_region_menu(context, user_id, chat_id, "üíÄ Voc√™ foi derrotado no calabou√ßo.")
                    return

                defeat_text = (
                    f"ùëΩùíêùíÑùíÜÃÇ ùíáùíêùíä ùíÖùíÜùíìùíìùíêùíïùíÇùíÖùíê ùíëùíÜùíçùíê {combat_details.get('monster_name','inimigo')}!"
                    + (f"\n\n‚ùå ùë∑ùíÜùíèùíÇùíçùíäùíÖùíÇùíÖùíÜ: Voc√™ perdeu {xp_lost} XP." if xp_lost > 0 else "")
                )
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=defeat_text,
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚û°Ô∏è ùêÇùê®ùêßùê≠ùê¢ùêßùêÆùêör", callback_data='continue_after_action')]])
                )
                return

            combat_details['battle_log'] = log
            player_data['player_state']['details'] = combat_details
            player_manager.save_player_data(user_id, player_data)

            new_text = format_combat_message(player_data)
            kb = [[InlineKeyboardButton("‚öîÔ∏è ùêÄùê≠ùêöùêúùêöùê´", callback_data='combat_attack'),
                   InlineKeyboardButton("üèÉ ùêÖùêÆùê†ùê¢ùê´", callback_data='combat_flee')]]
            reply_markup = InlineKeyboardMarkup(kb)
            await _edit_caption_only(query, new_text, reply_markup)
            return

    # =============================
    # ATAQUE
    # =============================
    if action == 'combat_attack':
        broken, w_uid, (w_cur, w_mx) = _weapon_broken(player_data)
        if broken:
            log.append(f"‚õî Sua arma est√° quebrada ({w_cur}/{w_mx}). ùëºùíîùíÜ ùíñùíé üìú ùë∑ùíÜùíìùíàùíÇùíéùíäùíèùíâùíê ùíÖùíÜ ùë´ùíñùíìùíÇùíÉùíäùíçùíäùíÖùíÇùíÖùíÜ ùíëùíÇùíìùíÇ ùíìùíÜùíîùíïùíÇùíñùíìùíÇùíì.")
            combat_details['battle_log'] = log
            player_data['player_state']['details'] = combat_details
            player_manager.save_player_data(user_id, player_data)

            new_text = format_combat_message(player_data)
            kb = [[InlineKeyboardButton("‚öîÔ∏è ùêÄùê≠ùêöùêúùêöùê´", callback_data='combat_attack'),
                   InlineKeyboardButton("üèÉ ùêÖùêÆùê†ùê¢ùê´", callback_data='combat_flee')]]
            await _edit_caption_only(query, new_text, InlineKeyboardMarkup(kb))
            return

        combat_details["used_weapon"] = True

        player_attack = int(player_total_stats.get('attack', 5))
        monster_defense = _mstat(combat_details, 'defense', 0)

        pparams = _crit_params_for_player(player_data)
        player_damage, pcrit, pmega = _roll_crit_and_damage(player_attack, monster_defense, pparams)

        if pcrit and pmega: log.append("üí• ùêåùêÑùêÜùêÄ ùêÇùêëùêàÃÅùêìùêàùêÇùêé! üí•")
        elif pcrit: log.append("‚ú® ùêÄùêÇùêÑùêëùêìùêé ùêÇùêëùêàÃÅùêìùêàùêÇùêé! ‚ú®")

        current_hp_before = int(combat_details.get('monster_hp', 1))
        combat_details['monster_hp'] = current_hp_before - player_damage
        if 'monster_max_hp' not in combat_details:
            combat_details['monster_max_hp'] = current_hp_before

        log.append(f"‚û°Ô∏è {player_data.get('character_name','ùëΩùíêùíÑùíÜÃÇ')} ùíÇùíïùíÇùíÑùíÇ!")
        log.append(f"üí• ùëΩùíêùíÑùíÜÃÇ ùíÑùíÇùíñùíîùíÇ {player_damage} ùíÖùíÜ ùíÖùíÇùíèùíê.")
        
        if combat_details['monster_hp'] > 0:
            double_attack_chance = player_manager.get_player_double_attack_chance(player_data)
            if random.random() < double_attack_chance:
                log.append("‚öîÔ∏è Com sua velocidade, voc√™ consegue um...")
                log.append("üí• ùêÄùêìùêÄùêêùêîùêÑ ùêÉùêîùêèùêãùêé! üí•")
                
                player_damage_2, pcrit_2, pmega_2 = _roll_crit_and_damage(player_attack, monster_defense, pparams)
                
                if pcrit_2 and pmega_2: log.append("üí• ùêåùêÑùêÜùêÄ ùêÇùêëùêàÃÅùêìùêàùêÇùêé no segundo golpe! üí•")
                elif pcrit_2: log.append("‚ú® ùêÄùêÇùêÑùêëùêìùêé ùêÇùêëùêàÃÅùêìùêàùêÇùêé no segundo golpe! ‚ú®")

                combat_details['monster_hp'] -= player_damage_2
                log.append(f"üí• ùëΩùíêùíÑùíÜÃÇ ùíÑùíÇùíñùíîùíÇ mais {player_damage_2} ùíÖùíÜ ùíÖùíÇùíèùíê.")
        
        # 2) Vit√≥ria ‚Üí fim de batalha + consumo
        if combat_details['monster_hp'] <= 0:
            _apply_end_of_battle_durability(player_data, combat_details, log)
            
            # Atualiza a miss√£o pessoal
            mission_manager.update_mission_progress(
                player_data, 'HUNT',
                details={'monster_id': combat_details.get('id'), 'region': combat_details.get('region_key'), 'is_elite': combat_details.get('is_elite', False)}
            )
            # Atualiza a miss√£o de guilda
            clan_id = player_data.get("clan_id")
            if clan_id:
                mission_details = {
                    'monster_id': combat_details.get('id'), 
                    'region': combat_details.get('region_key'), 
                    'is_elite': combat_details.get('is_elite', False), 
                    'count': 1
                }
                
                await clan_manager.update_guild_mission_progress(
                    clan_id=clan_id, 
                    mission_type='HUNT', 
                    details=mission_details, 
                    context=context)
            
            if combat_details.get('is_elite', False):
                mission_manager.update_mission_progress(
                    player_data, 'HUNT_ELITE',
                    details={'monster_id': combat_details.get('id'), 'region': combat_details.get('region_key')}
                )

            # Multiplicadores base (Premium, etc.)
            xp_mult = float(player_manager.get_player_perk_value(player_data, 'xp_multiplier', 1.0))
            gold_mult = float(player_manager.get_player_perk_value(player_data, 'gold_multiplier', 1.0))
            
            # ===============================================
            # ## IN√çCIO DA CORRE√á√ÉO: APLICAR BUFFS DO CL√É ##
            # ===============================================
            if clan_id:
                clan_buffs = clan_manager.get_clan_buffs(clan_id)
                
                # Adiciona o b√≥nus de XP do cl√£ (em percentagem)
                xp_bonus_percent = clan_buffs.get("xp_bonus_percent", 0)
                if xp_bonus_percent > 0:
                    xp_mult += (xp_bonus_percent / 100.0)
                
                # Adiciona o b√≥nus de Ouro do cl√£ (em percentagem)
                gold_bonus_percent = clan_buffs.get("gold_bonus_percent", 0)
                if gold_bonus_percent > 0:
                    gold_mult += (gold_bonus_percent / 100.0)
            # ===============================================
            # ## FIM DA CORRE√á√ÉO ##
            # ===============================================

            xp_reward = int(float(combat_details.get('monster_xp_reward', 0)) * xp_mult)
            gold_reward = int(float(combat_details.get('monster_gold_drop', 0)) * gold_mult)

            looted_items_list = []
            for item in combat_details.get('loot_table', []):
                if random.random() * 100 <= float(item.get('drop_chance', 0)):
                    item_id = item.get('item_id')
                    if item_id:
                        looted_items_list.append(item_id)
            
            if in_dungeon and _dungeon_advance_after_victory:
                rewards_package = { "xp": xp_reward, "gold": gold_reward, "items": looted_items_list }
                player_data['current_hp'] = int(player_manager.get_player_total_stats(player_data).get('max_hp', 50))
                player_manager.save_player_data(user_id, player_data)
                try: await query.delete_message()
                except Exception: pass
                await _dungeon_advance_after_victory(
                    update, context, user_id=user_id, chat_id=chat_id,
                    combat_details=combat_details, rewards_to_accumulate=rewards_package
                )
                return
            else:
                player_data['xp'] = int(player_data.get('xp', 0)) + xp_reward
                if gold_reward > 0:
                    player_manager.add_gold(player_data, gold_reward)

                looted_items_text = ""
                if looted_items_list:
                    looted_items_text = "\n\n<b>ùë∞ùíïùíÜùíèùíî ùë®ùíÖùííùíñùíäùíìùíäùíÖùíêùíî:</b>\n"
                    from collections import Counter
                    item_names = [(game_data.ITEMS_DATA.get(item_id, {}) or {}).get('display_name', item_id) for item_id in looted_items_list]
                    for name, count in Counter(item_names).items():
                        looted_items_text += f"- {count}x {name}\n"
                        item_key_to_add = next((key for key, val in game_data.ITEMS_DATA.items() if val.get('display_name') == name), name)
                        for _ in range(count):
                            player_manager.add_item_to_inventory(player_data, item_key_to_add)

                levels_gained, points_gained, level_up_message = 0, 0, ""
                while True:
                    current_level = int(player_data.get('level', 1))
                    xp_needed = int(game_data.get_xp_for_next_combat_level(current_level))
                    current_xp = int(player_data.get('xp', 0))
                    if current_xp < xp_needed: break
                    player_data['xp'] -= xp_needed
                    old_allowed = player_manager.allowed_points_for_level(player_data)
                    player_data['level'] = current_level + 1
                    new_allowed = player_manager.allowed_points_for_level(player_data)
                    delta_points = max(0, new_allowed - old_allowed)
                    player_data['stat_points'] = int(player_data.get('stat_points', 0)) + delta_points
                    levels_gained += 1
                    points_gained += delta_points        
                if levels_gained > 0:
            # Este 'if' agora serve APENAS para criar a mensagem de level up
                    nivel_txt = "n√≠vel" if levels_gained == 1 else "n√≠veis"
                    ponto_txt = "ponto" if points_gained == 1 else "pontos"
                    level_up_message = (f"\n\n‚ú® <b>Parab√©ns!</b> Voc√™ subiu {levels_gained} {nivel_txt} "
                                f"(agora Nv. {player_data['level']}) e ganhou {points_gained} {ponto_txt} de atributo.")
        
                
                player_data['current_hp'] = int(player_manager.get_player_total_stats(player_data).get('max_hp', 50))
                
                monster_name = combat_details.get('monster_name', 'inimigo')
                victory_summary = (f"‚úÖ Voc√™ derrotou {monster_name}!\n"
                                   f"+{xp_reward} XP, +{gold_reward} ouro."
                                   f"{looted_items_text}{level_up_message}")
                if xp_mult > 1 or gold_mult > 1:
                    victory_summary += "\n\n‚ú® ùë©ùíêÃÇùíèùíñùíî ùë∑ùíìùíÜùíéùíäùíñùíé ùíÇùíëùíçùíäùíÑùíÇùíÖùíê!"

                player_data['player_state'] = {'action': 'idle'}
                player_manager.save_player_data(user_id, player_data)

                try: await query.delete_message()
                except Exception: pass
                
                # =========================================================
                # üëá IN√çCIO DA NOVA L√ìGICA DE ENVIO DE M√çDIA üëá
                # =========================================================
                media_key_to_use = None
                if looted_items_list:
                    primeiro_item_id = looted_items_list[0]
                    item_info = (game_data.ITEMS_DATA or {}).get(primeiro_item_id, {})
                    media_key_to_use = item_info.get("media_key")
                if not media_key_to_use:
                    media_key_to_use = "vitoria_sem_item"

                media_data = file_ids.get_file_data(media_key_to_use)
                keyboard = [[InlineKeyboardButton("‚û°Ô∏è ùêÇùê®ùêßùê≠ùê¢ùêßùêÆùêöùê´", callback_data='continue_after_action')]]
                reply_markup = InlineKeyboardMarkup(keyboard)

                if media_data and media_data.get("id"):
                    media_id = media_data["id"]
                    media_type = (media_data.get("type") or "photo").lower()
                    try:
                        if media_type == "video":
                            await context.bot.send_video(chat_id=chat_id, video=media_id, caption=victory_summary, reply_markup=reply_markup, parse_mode='HTML')
                        else:
                            await context.bot.send_photo(chat_id=chat_id, photo=media_id, caption=victory_summary, reply_markup=reply_markup, parse_mode='HTML')
                    except Exception:
                        await context.bot.send_message(chat_id=chat_id, text=victory_summary, reply_markup=reply_markup, parse_mode='HTML')
                else:
                    await context.bot.send_message(chat_id=chat_id, text=victory_summary, reply_markup=reply_markup, parse_mode='HTML')
                # =========================================================
                # üëÜ FIM DA NOVA L√ìGICA üëÜ
                # =========================================================

                if int(player_data.get('level', 1)) >= 10 and not player_data.get('class'):
                    await show_class_selection_menu(update, context)
                return

        # 3) Monstro ataca
        dodge_chance = player_manager.get_player_dodge_chance(player_data)
        if random.random() < dodge_chance:
            log.append(f"‚ö°Ô∏è O inimigo tenta contra-atacar, mas voc√™ se ...")
            log.append("‚ö°Ô∏èüèÉ‚Äç‚ôÇÔ∏è‚Äç‚û°Ô∏è ùîºùïä‚ÑöùïåùïÄùïçùî∏! üåÄ")
        else:
            monster_attack = _mstat(combat_details, 'attack', 1)
            player_defense = int(player_total_stats.get('defense', 3))
            mparams = _crit_params_for_monster(combat_details)
            monster_damage, mcrit, mmega = _roll_crit_and_damage(monster_attack, player_defense, mparams)
            if mcrit and mmega: log.append("‚ò†Ô∏è ùêåùêÑùêÜùêÄ ùêÇùêëùêàÃÅùêìùêàùêÇùêé ùêÉùêé ùêàùêçùêàùêåùêàùêÜùêé! ‚ò†Ô∏è")
            elif mcrit: log.append("üíÄ ùêÇùêëùêàÃÅùêìùêàùêÇùêé ùêÉùêé ùêàùêçùêàùêåùêàùêÜùêé! üíÄ")
            combat_details["took_damage"] = True
            player_data['current_hp'] = int(player_data.get('current_hp', 0)) - monster_damage
            log.append(f"‚¨ÖÔ∏è {combat_details.get('monster_name','Inimigo')} ùíÇùíïùíÇùíÑùíÇ!")
            log.append(f"ü©∏ ùëΩùíêùíÑùíÜÃÇ ùíìùíÜùíÑùíÜùíÉùíÜ {monster_damage} ùíÖùíÜ ùíÖùíÇùíèùíê.")

        # 4) Derrota do jogador
        if player_data['current_hp'] <= 0:
            xp_lost = _apply_defeat_xp_penalty(player_data, combat_details)
            _apply_end_of_battle_durability(player_data, combat_details, log)
            player_data['current_hp'] = int(player_manager.get_player_total_stats(player_data).get('max_hp', 50))
            player_data['player_state'] = {'action': 'idle'}
            player_manager.save_player_data(user_id, player_data)
            try: await query.delete_message()
            except Exception: pass
            if in_dungeon:
                await _return_to_region_menu(context, user_id, chat_id, "üíÄ Voc√™ foi derrotado no calabou√ßo.")
                return
            defeat_text = (f"ùëΩùíêùíÑùíÜÃÇ ùíáùíêùíä ùíÖùíÜùíìùíìùíêùíïùíÇùíÖùíê ùíëùíÜùíçùíê {combat_details.get('monster_name','ùíäùíèùíäùíéùíäùíàùíê')}!"
                           + (f"\n\n‚ùå ùë∑ùíÜùíèùíÇùíçùíäùíÖùíÇùíÖùíÜ: Voc√™ perdeu {xp_lost} XP." if xp_lost > 0 else ""))
            await context.bot.send_message(
                chat_id=chat_id, text=defeat_text,
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚û°Ô∏è ùë™ùíêùíèùíïùíäùíèùíñùíÇùíì", callback_data='continue_after_action')]])
            )
            return

        # 5) Continuidade da luta
        combat_details['battle_log'] = log
        player_data['player_state']['details'] = combat_details
        player_manager.save_player_data(user_id, player_data)

        new_text = format_combat_message(player_data)
        kb = [[InlineKeyboardButton("‚öîÔ∏è ùêÄùê≠ùêöùêúùêöùê´", callback_data='combat_attack'),
               InlineKeyboardButton("üèÉ ùêÖùêÆùê†ùê¢ùê´", callback_data='combat_flee')]]
        reply_markup = InlineKeyboardMarkup(kb)
        await _edit_caption_only(query, new_text, reply_markup)

# -------------------------
# Continuar ‚Üí volta ao menu
# -------------------------
async def continue_after_action(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await _safe_answer(query)
    user_id = query.from_user.id
    chat_id = query.message.chat_id

    try:
        await query.delete_message()
    except Exception:
        pass

    await _return_to_region_menu(context, user_id, chat_id)


# Handlers
combat_handler = CallbackQueryHandler(combat_callback, pattern=r'^combat_(attack|flee)$')
continue_after_action_handler = CallbackQueryHandler(continue_after_action, pattern=r'^continue_after_action$')
