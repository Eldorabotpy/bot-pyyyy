# handlers/profile_handler.py (VERS√ÉO COMPLETA E CORRIGIDA)

import logging
import unicodedata
import re
import json
import html
from datetime import datetime, timezone
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CallbackQueryHandler, CommandHandler
from telegram.error import BadRequest
from modules.player.premium import PremiumManager
from modules import player_manager, game_data
from modules import file_ids
from modules.game_data.skins import SKIN_CATALOG
from modules.game_data import skills as skills_data

logger = logging.getLogger(__name__)

MAX_EQUIPPED_SKILLS = 4

# ===== util =====
def _slugify(text: str) -> str:
    if not text:
        return ""
    norm = unicodedata.normalize("NFKD", text)
    norm = norm.encode("ascii", "ignore").decode("ascii")
    norm = re.sub(r"\s+", "_", norm.strip().lower())
    norm = re.sub(r"[^a-z0-9_]", "", norm)
    return norm

# (Esta fun√ß√£o _get_class_media est√° correta, sem altera√ß√µes)
def _get_class_media(player_data: dict, purpose: str = "personagem"):
    raw_cls = (player_data.get("class") or player_data.get("class_tag") or "").strip()
    cls = _slugify(raw_cls)
    purpose = (purpose or "").strip().lower()
    candidates = []
    equipped_skin_id = player_data.get("equipped_skin")
    if equipped_skin_id and equipped_skin_id in SKIN_CATALOG:
        skin_info = SKIN_CATALOG[equipped_skin_id]
        if skin_info.get('class') == raw_cls or skin_info.get('class') == cls:
            candidates.append(skin_info['media_key'])
    classes_data = getattr(game_data, "CLASSES_DATA", {}) or {}
    cls_cfg = classes_data.get(raw_cls) or classes_data.get(cls) or {}
    for k in ("profile_file_id_key", "profile_media_key", "file_id_name", "status_file_id_key", "file_id_key"):
        if cls_cfg and cls_cfg.get(k):
            candidates.append(cls_cfg[k])
    if cls:
        candidates += [
            f"classe_{cls}_media", f"class_{cls}_media", f"{cls}_media",
            f"perfil_video_{cls}", f"personagem_video_{cls}", f"profile_video_{cls}",
            f"{purpose}_video_{cls}", f"{purpose}_{cls}",
            f"{cls}_{purpose}_video", f"{cls}_{purpose}",
        ]
    candidates += ["perfil_video", "personagem_video", "profile_video", "perfil_foto", "profile_photo"]
    tried = []
    for key in [k for k in candidates if k and "abertura" not in k.lower()]:
        tried.append(key)
        fd = file_ids.get_file_data(key)
        if fd and fd.get("id"):
            logger.info("[PROFILE_MEDIA] purpose=%s class=%s slug=%s chosen=%s", purpose, raw_cls, cls, key)
            return fd
    logger.info("[PROFILE_MEDIA] purpose=%s class=%s slug=%s chosen=None tried=%s", purpose, raw_cls, cls, tried)
    return None

# (Esta fun√ß√£o _safe_edit_or_send est√° correta, sem altera√ß√µes)
async def _safe_edit_or_send(query, context, chat_id, text, reply_markup=None, parse_mode='HTML'):
    try:
        await query.edit_message_caption(caption=text, reply_markup=reply_markup, parse_mode=parse_mode); return
    except Exception:
        pass
    try:
        await query.edit_message_text(text=text, reply_markup=reply_markup, parse_mode=parse_mode); return
    except Exception:
        pass
    # Fallback: se tudo falhar, envia uma nova mensagem
    try:
        await context.bot.send_message(chat_id=chat_id, text=text, reply_markup=reply_markup, parse_mode=parse_mode)
    except Exception as e:
        logger.error(f"Falha ao enviar mensagem em _safe_edit_or_send: {e}")

# (Todas as fun√ß√µes de skills e utils (_bar, _normalize_profession, etc.) est√£o corretas, sem altera√ß√µes)
async def show_skills_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    chat_id = query.message.chat_id
    player_data = await player_manager.get_player_data(user_id)
    if not player_data:
        await _safe_edit_or_send(query, context, chat_id, "Erro: Personagem n√£o encontrado.")
        return
    player_skill_ids = player_data.get("skills", [])
    if not player_skill_ids:
        text = "üìö <b>Suas Habilidades</b>\n\nVoc√™ ainda n√£o aprendeu nenhuma habilidade."
        kb = [[InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Perfil", callback_data="profile")]]
        await _safe_edit_or_send(query, context, chat_id, text, InlineKeyboardMarkup(kb))
        return
    active_skills_lines = []
    passive_skills_lines = []
    for skill_id in player_skill_ids:
        skill_info = skills_data.SKILL_DATA.get(skill_id)
        if not skill_info:
            logger.warning(f"Skill ID '{skill_id}' encontrado em {user_id} mas n√£o existe em SKILL_DATA.")
            continue
        name = skill_info.get("display_name", skill_id)
        desc = skill_info.get("description", "Sem descri√ß√£o.")
        mana_cost = skill_info.get("mana_cost")
        skill_type = skill_info.get("type", "unknown")
        line = f"‚Ä¢ <b>{name}</b>"
        if mana_cost is not None:
            line += f" ({mana_cost} MP)"
        line += f": <i>{html.escape(desc)}</i>"
        if skill_type == "active" or skill_type.startswith("support"):
            active_skills_lines.append(line)
        elif skill_type == "passive":
            passive_skills_lines.append(line)
    text_parts = ["üìö <b>Suas Habilidades</b>\n"]
    if active_skills_lines:
        text_parts.append("‚ú® <b><u>Habilidades Ativas</u></b> ‚ú®")
        text_parts.extend(active_skills_lines)
        text_parts.append("(Voc√™ pode equipar at√© 4 skills ativas para usar em combate)")
        text_parts.append("")
    if passive_skills_lines:
        text_parts.append("üõ°Ô∏è <b><u>Habilidades Passivas</u></b> üõ°Ô∏è")
        text_parts.extend(passive_skills_lines)
        text_parts.append("")
    kb = [[InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Perfil", callback_data="profile")]]
    if active_skills_lines:
        kb.insert(0, [InlineKeyboardButton("‚öôÔ∏è Equipar Skills Ativas", callback_data="skills_equip_menu")])
    final_text = "\n".join(text_parts)
    reply_markup = InlineKeyboardMarkup(kb)
    await _safe_edit_or_send(query, context, chat_id, final_text, reply_markup)

async def show_equip_skills_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    chat_id = query.message.chat.id
    player_data = await player_manager.get_player_data(user_id)
    if not player_data:
        await _safe_edit_or_send(query, context, chat_id, "Erro: Personagem n√£o encontrado.")
        return
    all_skill_ids = player_data.get("skills", [])
    equipped_ids = player_data.get("equipped_skills", [])
    if not isinstance(equipped_ids, list):
        equipped_ids = []
        player_data["equipped_skills"] = equipped_ids
    active_skill_ids = [
        skill_id for skill_id in all_skill_ids
        if skills_data.SKILL_DATA.get(skill_id, {}).get("type") == "active" or
           skills_data.SKILL_DATA.get(skill_id, {}).get("type", "").startswith("support")
    ]
    if not active_skill_ids:
        text = "‚öôÔ∏è Equipar Skills Ativas\n\nVoc√™ n√£o possui nenhuma skill ativa para equipar."
        kb = [[InlineKeyboardButton("‚¨ÖÔ∏è Voltar (Habilidades)", callback_data="skills_menu_open")]]
        await _safe_edit_or_send(query, context, chat_id, text, InlineKeyboardMarkup(kb))
        return
    text_parts = [f"‚öôÔ∏è <b>Equipar Skills Ativas</b> (Limite: {len(equipped_ids)}/{MAX_EQUIPPED_SKILLS})\n"]
    kb_rows = []
    text_parts.append("‚úÖ <b><u>Equipadas Atualmente</u></b> ‚úÖ")
    if not equipped_ids:
        text_parts.append("<i>Nenhuma skill ativa equipada.</i>")
    else:
        for skill_id in equipped_ids:
            skill_info = skills_data.SKILL_DATA.get(skill_id)
            if not skill_info: continue
            name = skill_info.get("display_name", skill_id)
            mana_cost = skill_info.get("mana_cost")
            line = f"‚Ä¢ <b>{name}</b>"
            if mana_cost is not None: line += f" ({mana_cost} MP)"
            text_parts.append(line)
            kb_rows.append([InlineKeyboardButton(f"‚ûñ Desequipar {name}", callback_data=f"unequip_skill:{skill_id}")])
    text_parts.append("\n" + ("‚îÄ" * 20) + "\n")
    text_parts.append("‚ûï <b><u>Dispon√≠veis para Equipar</u></b> ‚ûï")
    slots_free = MAX_EQUIPPED_SKILLS - len(equipped_ids)
    available_to_equip_found = False
    for skill_id in active_skill_ids:
        if skill_id not in equipped_ids:
            available_to_equip_found = True
            skill_info = skills_data.SKILL_DATA.get(skill_id)
            if not skill_info: continue
            name = skill_info.get("display_name", skill_id)
            mana_cost = skill_info.get("mana_cost")
            line = f"‚Ä¢ <b>{name}</b>"
            if mana_cost is not None: line += f" ({mana_cost} MP)"
            text_parts.append(line)
            if slots_free > 0:
                kb_rows.append([InlineKeyboardButton(f"‚ûï Equipar {name}", callback_data=f"equip_skill:{skill_id}")])
            else:
                kb_rows.append([InlineKeyboardButton(f"üö´ Limite Atingido", callback_data="noop")])
    if not available_to_equip_found:
       text_parts.append("<i>N√£o h√° outras skills ativas dispon√≠veis ou todas j√° est√£o equipadas.</i>")
    kb_rows.append([InlineKeyboardButton("‚¨ÖÔ∏è Voltar (Habilidades)", callback_data="skills_menu_open")])
    final_text = "\n".join(text_parts)
    reply_markup = InlineKeyboardMarkup(kb_rows)
    await _safe_edit_or_send(query, context, chat_id, final_text, reply_markup)

async def equip_skill_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    try:
        skill_id = query.data.split(":", 1)[1]
    except IndexError:
        logger.error(f"Callback equip_skill inv√°lido: {query.data}")
        await query.answer("Erro ao processar a a√ß√£o.", show_alert=True)
        return
    player_data = await player_manager.get_player_data(user_id)
    if not player_data:
        await query.answer("Erro: Personagem n√£o encontrado.", show_alert=True)
        return
    equipped_skills = player_data.setdefault("equipped_skills", [])
    if not isinstance(equipped_skills, list):
        equipped_skills = []
        player_data["equipped_skills"] = equipped_skills
    if skill_id in equipped_skills:
        await query.answer("Essa skill j√° est√° equipada.", show_alert=True)
        await show_equip_skills_menu(update, context)
        return
    if len(equipped_skills) >= MAX_EQUIPPED_SKILLS:
        await query.answer(f"Limite de {MAX_EQUIPPED_SKILLS} skills equipadas atingido!", show_alert=True)
        await show_equip_skills_menu(update, context)
        return
    equipped_skills.append(skill_id)
    await player_manager.save_player_data(user_id, player_data)
    await show_equip_skills_menu(update, context)

async def unequip_skill_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    try:
        skill_id = query.data.split(":", 1)[1]
    except IndexError:
        logger.error(f"Callback unequip_skill inv√°lido: {query.data}")
        await query.answer("Erro ao processar a a√ß√£o.", show_alert=True)
        return
    player_data = await player_manager.get_player_data(user_id)
    if not player_data:
        await query.answer("Erro: Personagem n√£o encontrado.", show_alert=True)
        return
    equipped_skills = player_data.get("equipped_skills", [])
    if not isinstance(equipped_skills, list):
        equipped_skills = []
        player_data["equipped_skills"] = equipped_skills
    if skill_id in equipped_skills:
        equipped_skills.remove(skill_id)
        await player_manager.save_player_data(user_id, player_data)
    else:
        await query.answer("Essa skill n√£o estava equipada.", show_alert=True)
    await show_equip_skills_menu(update, context)

async def noop_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer("Limite de skills equipadas atingido!")

def _bar(current: int, total: int, blocks: int = 10, filled_char: str = 'üüß', empty_char: str = '‚¨úÔ∏è') -> str:
    if total <= 0:
        filled = blocks
    else:
        ratio = max(0.0, min(1.0, float(current) / float(total)))
        filled = int(round(ratio * blocks))
    return filled_char * filled + empty_char * (blocks - filled)

def _normalize_profession(raw):
    if not raw:
        return None
    if isinstance(raw, str):
        return (raw, 1, 0)
    if isinstance(raw, dict) and ('type' in raw):
        t = raw.get('type') or None
        if not t: return None
        return (t, int(raw.get('level', 1)), int(raw.get('xp', 0)))
    if isinstance(raw, dict):
        for k, v in raw.items():
            if isinstance(v, dict):
                return (k, int(v.get('level', 1)), int(v.get('xp', 0)))
            return (k, 1, 0)
    return None

def _class_key_from_player(player_data: dict) -> str:
    if player_data.get("class_key"):
        return str(player_data["class_key"])
    raw = (player_data.get("class") or "").strip()
    return _slugify(raw) or "_default"

# ====================================================================
# <<< IN√çCIO DA CORRE√á√ÉO PRINCIPAL >>>
# ====================================================================

async def profile_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Fun√ß√£o unificada para lidar com /personagem (comando) e 'profile' (bot√£o).
    """
    query = update.callback_query
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id
    
    # Responde ao clique do bot√£o, se for um
    if query:
        await query.answer()

    # <<< CORRE√á√ÉO: Adiciona await >>>
    player_data = await player_manager.get_player_data(user_id)

    if not player_data:
        text = "Erro: Personagem n√£o encontrado. Use /start para come√ßar."
        if query:
            await _safe_edit_or_send(query, context, chat_id, text)
        else:
            await context.bot.send_message(chat_id, text)
        return
    
    # ===== totais (base + equipamentos) =====
    
    # <<< CORRE√á√ÉO: Adiciona await >>>
    totals = await player_manager.get_player_total_stats(player_data)
    
    total_hp_max = int(totals.get('max_hp', 50))
    total_atk = int(totals.get('attack', 0))
    total_def = int(totals.get('defense', 0))
    total_ini = int(totals.get('initiative', 0))
    total_luck = int(totals.get('luck', 0))

    current_hp = max(0, min(int(player_data.get('current_hp', total_hp_max)), total_hp_max))
    
    # <<< CORRE√á√ÉO: Adiciona await >>>
    chance_esquiva = int((await player_manager.get_player_dodge_chance(player_data)) * 100)
    # <<< CORRE√á√ÉO: Adiciona await >>>
    chance_ataque_duplo = int((await player_manager.get_player_double_attack_chance(player_data)) * 100)

    location_key = player_data.get('current_location', 'reino_eldora')
    location_name = (game_data.REGIONS_DATA or {}).get(location_key, {}).get('display_name', 'Lugar Desconhecido')

    # ===== BLOCO PREMIUM =====
    premium_line = ""
    premium = PremiumManager(player_data)
    if premium.is_premium():
        tier_name = premium.tier.capitalize() if premium.tier else "Premium"
        exp_date = premium.expiration_date
        premium_line = f"\nüëë <b>Status Premium:</b> {tier_name}"
        if exp_date:
            premium_line += f"\n(Expira em: {exp_date.strftime('%d/%m/%Y')})"
        else:
            premium_line += " (Permanente)"
    
    # ===== XP, Profiss√£o, Classe =====
    # <<< CORRE√á√ÉO: Adiciona await >>>
    max_energy  = int(await player_manager.get_player_max_energy(player_data))
    combat_level = int(player_data.get('level', 1))
    combat_xp = int(player_data.get('xp', 0))
    try:
        combat_next = int(game_data.get_xp_for_next_combat_level(combat_level))
    except Exception:
        combat_next = 0
    combat_bar = _bar(combat_xp, combat_next)

    prof_line = "" 
    prof_norm = _normalize_profession(player_data.get('profession'))
    if prof_norm:
        prof_key, prof_level, prof_xp = prof_norm
        prof_name = (game_data.PROFESSIONS_DATA or {}).get(prof_key, {}).get('display_name', prof_key)
        try:
            prof_next = int(game_data.get_xp_for_next_collection_level(prof_level))
        except Exception:
            prof_next = 0
        prof_bar = _bar(prof_xp, prof_next, blocks=10, filled_char='üü®', empty_char='‚¨úÔ∏è')
        prof_line = f"\nüíº <b>Profiss√£o:</b> {prof_name} ‚Äî N√≠vel {prof_level}\n<code>[{prof_bar}]</code> {prof_xp}/{prof_next} XP"
    
    class_banner = ""
    if player_manager.needs_class_choice(player_data):
        class_banner = "\n\n‚ú® <b>Escolha sua Classe!</b>"

    current_class_key = (player_data.get("class") or "no_class").lower()
    class_config = (game_data.CLASSES_DATA or {}).get(current_class_key, {})
    class_name = class_config.get("display_name", current_class_key.title())
    class_emoji = class_config.get("emoji", "üë§")

    # ===== texto do perfil =====
    char_name = player_data.get('character_name','Aventureiro(a)')
    available_points = int(player_data.get("stat_points", 0) or 0)

    lines = [
        f"üë§ <b>P·¥á Ä“ì…™ ü ·¥Ö·¥á {char_name}</b>{premium_line}",
        f"{class_emoji} <b>Classe:</b> {class_name}", 
        f"üìç <b>ùë≥ùíêùíÑùíÇùíçùíäíûõùíÇùíÑÃßùíÇÃÉùíê ùë®ùíïùíñùíÇùíç:</b> {location_name}",
        "",
        f"‚ù§Ô∏è <b>ùêáùêè:</b> {current_hp} / {total_hp_max}",
        f"‚ö°Ô∏è <b>ùêÑùêßùêûùê´ùê†ùê¢ùêö:</b> {int(player_data.get('energy', 0))} / {max_energy}",
        "",
        f"üß° <b>ùêáùêè ùêåùêöÃÅùê±ùê¢ùê¶ùê®:</b> {total_hp_max}",
        f"‚öîÔ∏è <b>ùêÄùê≠ùêöùê™ùêÆùêû:</b> {total_atk}",
        f"üõ°Ô∏è <b>ùêÉùêûùêüùêûùê¨ùêö:</b> {total_def}",
        f"üèÉ <b>ùêàùêßùê¢ùêúùê¢ùêöùê≠ùê¢ùêØùêö:</b> {total_ini}",
        f"üçÄ <b>ùêíùê®ùê´ùê≠ùêû:</b> {total_luck}",
        f"‚ö°Ô∏è <b>Chance de Esquiva:</b> {chance_esquiva}%",
        f"‚öîÔ∏è <b>Chance de Ataque Duplo:</b> {chance_ataque_duplo}%",
        "",
        f"üéØ <b>ùë∑ùíêùíèùíïùíêùíî ùíÖùíÜ ùë®ùíïùíìùíäùíÉùíñùíïùíê ùíÖùíäùíîùíëùíêùíèùíäÃÅùíóùíÜùíäùíî:</b> {available_points}",
        f"üéñÔ∏è <b>ùëµùíäÃÅùíóùíÜùíç ùíÖùíÜ ùë™ùíêùíéùíÉùíÇùíïùíÜ:</b> {combat_level}\n<code>[{combat_bar}]</code> {combat_xp}/{combat_next} ùêóùêè",
    ]
    if prof_line:
        lines.append(prof_line)
    if class_banner:
        lines.append(class_banner)

    profile_text = "\n".join(lines)

    # ===== teclado =====
    keyboard = []
    if player_manager.needs_class_choice(player_data):
        keyboard.append([InlineKeyboardButton("‚ú® ùêÑùê¨ùêúùê®ùê•ùê°ùêûùê´ ùêÇùê•ùêöùê¨ùê¨ùêû", callback_data='class_open')])
    if not prof_norm:
        keyboard.append([InlineKeyboardButton("üíº ùêÑùê¨ùêúùê®ùê•ùê°ùêûùê´ ùêèùê´ùê®ùêüùê¢ùê¨ùê¨ùêöÃÉùê®", callback_data='job_menu')])

    keyboard.extend([
        [InlineKeyboardButton("ÍßÅìäàíÜúüÖ≤üÖªüÖ∞üÖΩíÜúìäâÍßÇ", callback_data='clan_menu:profile')],
        [InlineKeyboardButton("üìä ùêíùê≠ùêöùê≠ùêÆùê¨ & ùêÄùê≠ùê´ùê¢ùêõùêÆùê≠ùê®ùê¨", callback_data='status_open')],
        [InlineKeyboardButton("üß∞ ùêÑùê™ùêÆùê¢ùê©ùêöùê¶ùêûùêßùê≠ùê®ùê¨", callback_data='equipment_menu')],
        [InlineKeyboardButton("üéí ùêïùêûùê´ ùêàùêßùêØùêûùêßùê≠ùêöÃÅùê´ùê¢ùê® ùêÇùê®ùê¶ùê©ùê•ùêûto", callback_data='inventory_CAT_equipamento_PAGE_1')],
        [InlineKeyboardButton("üß™ ùêîùê¨ùêöùê´ ùêÇùê®ùêßùê¨ùêÆùê¶ùê¢ÃÅùêØùêûùê•", callback_data='potion_menu')],
        [InlineKeyboardButton("üìö ùêáùêöùêõùê¢ùê•ùê¢ùêùùêöùêùùêûùê¨", callback_data='skills_menu_open')],
        [InlineKeyboardButton("üé® ùêåùêÆùêùùêöùê´ ùêÄùê©ùêöùê´ùêûÃÇùêßùêúùê¢ùêö", callback_data='skin_menu')],
        [InlineKeyboardButton("‚¨ÖÔ∏è ùêïùê®ùê•ùê≠ùêöùê´", callback_data='continue_after_action')],
    ])
    reply_markup = InlineKeyboardMarkup(keyboard)

    # ===== m√≠dia da classe =====
    media = _get_class_media(player_data, "personagem")
    if media and media.get("id"):
        try:
            # Tenta deletar a mensagem antiga (se for um callback)
            if query:
                await query.delete_message()

            fid  = media["id"]
            ftyp = (media.get("type") or "photo").lower()
            if ftyp == "video":
                await context.bot.send_video(chat_id=chat_id, video=fid, caption=profile_text, reply_markup=reply_markup, parse_mode="HTML")
            else:
                await context.bot.send_photo(chat_id=chat_id, photo=fid, caption=profile_text, reply_markup=reply_markup, parse_mode="HTML")
            return 
        except Exception as e:
            logger.error(f"Falha ao enviar m√≠dia do perfil para user {user_id}: {e}")
            # Continua para o fallback de texto

    # Fallback: sem m√≠dia (ou se a m√≠dia falhou)
    if query:
        # Se veio de um bot√£o, edita a mensagem atual
        await _safe_edit_or_send(query, context, chat_id, profile_text, reply_markup=reply_markup, parse_mode='HTML')
    else:
        # Se veio de um comando (/personagem), envia uma nova mensagem
        await context.bot.send_message(chat_id=chat_id, text=profile_text, reply_markup=reply_markup, parse_mode="HTML")

# ====================================================================
# <<< FIM DA CORRE√á√ÉO PRINCIPAL >>>
# ====================================================================


# ====================================================================
# <<< IN√çCIO DAS EXPORTA√á√ïES DE HANDLER (O QUE FALTAVA) >>>
# ====================================================================

# O handler para o comando /personagem
character_command_handler = CommandHandler("personagem", profile_callback)

# O handler para o bot√£o 'profile' (ex: "Voltar ao Perfil")
profile_handler = CallbackQueryHandler(profile_callback, pattern=r'^(?:profile|personagem)$')

# Handlers para os sub-menus de skills (que est√£o neste ficheiro)
skills_menu_handler = CallbackQueryHandler(show_skills_menu, pattern=r'^skills_menu_open$')
skills_equip_menu_handler = CallbackQueryHandler(show_equip_skills_menu, pattern=r'^skills_equip_menu$')
equip_skill_handler = CallbackQueryHandler(equip_skill_callback, pattern=r'^equip_skill:')
unequip_skill_handler = CallbackQueryHandler(unequip_skill_callback, pattern=r'^unequip_skill:')
noop_handler = CallbackQueryHandler(noop_callback, pattern=r'^noop$')

# ====================================================================
# <<< FIM DAS EXPORTA√á√ïES DE HANDLER >>>
# ====================================================================