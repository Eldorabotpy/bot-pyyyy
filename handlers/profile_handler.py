# handlers/profile_handler.py

import logging
import unicodedata
import re
import json
import html
from datetime import datetime, timezone
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CallbackQueryHandler, CommandHandler
from telegram.error import BadRequest
from modules.player.premium import PremiumManager
from modules import player_manager, game_data
from modules import file_ids
from modules.game_data.skins import SKIN_CATALOG
from modules.game_data import skills as skills_data

logger = logging.getLogger(__name__)

MAX_EQUIPPED_SKILLS = 4

# ===== util =====
def _slugify(text: str) -> str:
    if not text:
        return ""
    norm = unicodedata.normalize("NFKD", text)
    norm = norm.encode("ascii", "ignore").decode("ascii")
    norm = re.sub(r"\s+", "_", norm.strip().lower())
    norm = re.sub(r"[^a-z0-9_]", "", norm)
    return norm

def _get_class_media(player_data: dict, purpose: str = "personagem"):
    """
    Encontra m√≠dia para a classe do jogador, dando prioridade √† skin equipada.
    """
    raw_cls = (player_data.get("class") or player_data.get("class_tag") or "").strip()
    cls = _slugify(raw_cls)
    purpose = (purpose or "").strip().lower()

    candidates = []
    
    # --- L√ìGICA DE SKIN ---
    # 1. Primeiro, tenta encontrar a media_key da skin equipada
    equipped_skin_id = player_data.get("equipped_skin")
    if equipped_skin_id and equipped_skin_id in SKIN_CATALOG:
        skin_info = SKIN_CATALOG[equipped_skin_id]
        # Garante que a skin pertence √† classe do jogador
        if skin_info.get('class') == raw_cls or skin_info.get('class') == cls:
             candidates.append(skin_info['media_key'])
    # --- FIM DA L√ìGICA DE SKIN ---
            
    # 2) Se n√£o encontrar skin, continua com a l√≥gica original de procurar a m√≠dia padr√£o
    classes_data = getattr(game_data, "CLASSES_DATA", {}) or {}
    cls_cfg = classes_data.get(raw_cls) or classes_data.get(cls) or {}
    for k in ("profile_file_id_key", "profile_media_key", "file_id_name", "status_file_id_key", "file_id_key"):
        if cls_cfg and cls_cfg.get(k):
            candidates.append(cls_cfg[k])

    # 3) Padr√µes por classe
    if cls:
        candidates += [
            f"classe_{cls}_media",
            f"class_{cls}_media",
            f"{cls}_media",
            f"perfil_video_{cls}",
            f"personagem_video_{cls}",
            f"profile_video_{cls}",
            f"{purpose}_video_{cls}",
            f"{purpose}_{cls}",
            f"{cls}_{purpose}_video",
            f"{cls}_{purpose}",
        ]

    # 4) Fallbacks gen√©ricos
    candidates += ["perfil_video", "personagem_video", "profile_video", "perfil_foto", "profile_photo"]

    # 5) Procura pelo primeiro file_id v√°lido na lista de candidatos
    tried = []
    for key in [k for k in candidates if k and "abertura" not in k.lower()]:
        tried.append(key)
        fd = file_ids.get_file_data(key)
        if fd and fd.get("id"):
            logger.info("[PROFILE_MEDIA] purpose=%s class=%s slug=%s chosen=%s", purpose, raw_cls, cls, key)
            return fd

    logger.info("[PROFILE_MEDIA] purpose=%s class=%s slug=%s chosen=None tried=%s", purpose, raw_cls, cls, tried)
    return None

async def show_skills_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra a lista de habilidades ativas e passivas do jogador."""
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    chat_id = query.message.chat_id

    player_data = await player_manager.get_player_data(user_id)
    if not player_data:
        await _safe_edit_or_send(query, context, chat_id, "Erro: Personagem n√£o encontrado.")
        return

    player_skill_ids = player_data.get("skills", [])
    if not player_skill_ids:
        text = "üìö <b>Suas Habilidades</b>\n\nVoc√™ ainda n√£o aprendeu nenhuma habilidade."
        kb = [[InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Perfil", callback_data="profile")]]
        await _safe_edit_or_send(query, context, chat_id, text, InlineKeyboardMarkup(kb))
        return

    active_skills_lines = []
    passive_skills_lines = []

    for skill_id in player_skill_ids:
        skill_info = skills_data.SKILL_DATA.get(skill_id)
        if not skill_info:
            logger.warning(f"Skill ID '{skill_id}' encontrado nos dados do jogador {user_id} mas n√£o existe em SKILL_DATA.")
            continue

        name = skill_info.get("display_name", skill_id)
        desc = skill_info.get("description", "Sem descri√ß√£o.")
        mana_cost = skill_info.get("mana_cost")
        skill_type = skill_info.get("type", "unknown")

        line = f"‚Ä¢ <b>{name}</b>"
        if mana_cost is not None:
            line += f" ({mana_cost} MP)"
        line += f": <i>{html.escape(desc)}</i>" # Usa html.escape

        if skill_type == "active" or skill_type.startswith("support"):
            active_skills_lines.append(line)
        elif skill_type == "passive":
            passive_skills_lines.append(line)

    # Monta o texto final
    text_parts = ["üìö <b>Suas Habilidades</b>\n"]

    if active_skills_lines:
        text_parts.append("‚ú® <b><u>Habilidades Ativas</u></b> ‚ú®")
        text_parts.extend(active_skills_lines)
        text_parts.append("(Voc√™ pode equipar at√© 4 skills ativas para usar em combate)") # Informa o limite
        text_parts.append("")

    if passive_skills_lines:
        text_parts.append("üõ°Ô∏è <b><u>Habilidades Passivas</u></b> üõ°Ô∏è")
        text_parts.extend(passive_skills_lines)
        text_parts.append("")

    # --- IN√çCIO DA MUDAN√áA NO TECLADO ---
    # Teclado inicial apenas com bot√£o de voltar ao perfil
    kb = [[InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Perfil", callback_data="profile")]]

    # Adiciona o bot√£o "Equipar Skills" APENAS se houver skills ativas para equipar
    if active_skills_lines:
        kb.insert(0, [InlineKeyboardButton("‚öôÔ∏è Equipar Skills Ativas", callback_data="skills_equip_menu")])
    # --- FIM DA MUDAN√áA NO TECLADO ---

    final_text = "\n".join(text_parts)
    reply_markup = InlineKeyboardMarkup(kb)

    # Usa a fun√ß√£o segura para editar (idealmente) ou enviar a nova mensagem
    await _safe_edit_or_send(query, context, chat_id, final_text, reply_markup)

async def show_equip_skills_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra o menu para equipar/desequipar skills ativas."""
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    chat_id = query.message.chat_id

    player_data = await player_manager.get_player_data(user_id)
    if not player_data:
        await _safe_edit_or_send(query, context, chat_id, "Erro: Personagem n√£o encontrado.")
        return

    all_skill_ids = player_data.get("skills", [])
    # Garante que equipped_skills existe e √© uma lista
    equipped_ids = player_data.get("equipped_skills", [])
    if not isinstance(equipped_ids, list):
        equipped_ids = []
        player_data["equipped_skills"] = equipped_ids # Corrige se n√£o for lista

    # Filtra apenas skills ativas/suporte
    active_skill_ids = [
        skill_id for skill_id in all_skill_ids
        if skills_data.SKILL_DATA.get(skill_id, {}).get("type") == "active" or
           skills_data.SKILL_DATA.get(skill_id, {}).get("type", "").startswith("support")
    ]

    if not active_skill_ids:
        text = "‚öôÔ∏è Equipar Skills Ativas\n\nVoc√™ n√£o possui nenhuma skill ativa para equipar."
        kb = [[InlineKeyboardButton("‚¨ÖÔ∏è Voltar (Habilidades)", callback_data="skills_menu_open")]]
        await _safe_edit_or_send(query, context, chat_id, text, InlineKeyboardMarkup(kb))
        return

    text_parts = [f"‚öôÔ∏è <b>Equipar Skills Ativas</b> (Limite: {len(equipped_ids)}/{MAX_EQUIPPED_SKILLS})\n"]
    kb_rows = []

    # --- Sec√ß√£o: Skills Equipadas ---
    text_parts.append("‚úÖ <b><u>Equipadas Atualmente</u></b> ‚úÖ")
    if not equipped_ids:
        text_parts.append("<i>Nenhuma skill ativa equipada.</i>")
    else:
        for skill_id in equipped_ids:
            skill_info = skills_data.SKILL_DATA.get(skill_id)
            if not skill_info: continue # Seguran√ßa
            name = skill_info.get("display_name", skill_id)
            mana_cost = skill_info.get("mana_cost")
            line = f"‚Ä¢ <b>{name}</b>"
            if mana_cost is not None: line += f" ({mana_cost} MP)"
            text_parts.append(line)
            # Bot√£o para desequipar
            kb_rows.append([InlineKeyboardButton(f"‚ûñ Desequipar {name}", callback_data=f"unequip_skill:{skill_id}")])

    text_parts.append("\n" + ("‚îÄ" * 20) + "\n") # Separador

    # --- Sec√ß√£o: Skills Dispon√≠veis ---
    text_parts.append("‚ûï <b><u>Dispon√≠veis para Equipar</u></b> ‚ûï")
    slots_free = MAX_EQUIPPED_SKILLS - len(equipped_ids)
    available_to_equip_found = False

    for skill_id in active_skill_ids:
        # Mostra apenas as skills ativas que N√ÉO est√£o equipadas
        if skill_id not in equipped_ids:
            available_to_equip_found = True
            skill_info = skills_data.SKILL_DATA.get(skill_id)
            if not skill_info: continue
            name = skill_info.get("display_name", skill_id)
            mana_cost = skill_info.get("mana_cost")
            line = f"‚Ä¢ <b>{name}</b>"
            if mana_cost is not None: line += f" ({mana_cost} MP)"
            text_parts.append(line)

            # Bot√£o para equipar (se houver espa√ßo)
            if slots_free > 0:
                kb_rows.append([InlineKeyboardButton(f"‚ûï Equipar {name}", callback_data=f"equip_skill:{skill_id}")])
            else:
                # Bot√£o "desativado" (n√£o faz nada ao clicar) se o limite foi atingido
                kb_rows.append([InlineKeyboardButton(f"üö´ Limite Atingido", callback_data="noop")]) # 'noop' = no operation

    if not available_to_equip_found:
         text_parts.append("<i>N√£o h√° outras skills ativas dispon√≠veis ou todas j√° est√£o equipadas.</i>")

    # Bot√£o para voltar ao menu anterior de skills
    kb_rows.append([InlineKeyboardButton("‚¨ÖÔ∏è Voltar (Habilidades)", callback_data="skills_menu_open")])

    final_text = "\n".join(text_parts)
    reply_markup = InlineKeyboardMarkup(kb_rows)

    await _safe_edit_or_send(query, context, chat_id, final_text, reply_markup)

async def equip_skill_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Equipa uma skill ativa se houver espa√ßo."""
    query = update.callback_query
    # Responde imediatamente para o Telegram saber que recebemos o clique
    await query.answer()
    user_id = query.from_user.id

    try:
        # Extrai o ID da skill do callback_data (formato: "equip_skill:skill_id")
        skill_id = query.data.split(":", 1)[1]
    except IndexError:
        logger.error(f"Callback equip_skill inv√°lido: {query.data}")
        await query.answer("Erro ao processar a a√ß√£o.", show_alert=True)
        return

    player_data = await player_manager.get_player_data(user_id)
    if not player_data:
        # N√£o edita a mensagem aqui, apenas avisa
        await query.answer("Erro: Personagem n√£o encontrado.", show_alert=True)
        return

    # Garante que a lista existe e obt√©m a lista atual
    equipped_skills = player_data.setdefault("equipped_skills", [])
    if not isinstance(equipped_skills, list): # Seguran√ßa extra
        equipped_skills = []
        player_data["equipped_skills"] = equipped_skills

    # Verifica se a skill j√° est√° equipada (seguran√ßa)
    if skill_id in equipped_skills:
        await query.answer("Essa skill j√° est√° equipada.", show_alert=True)
        # Atualiza o menu caso haja inconsist√™ncia
        await show_equip_skills_menu(update, context)
        return

    # Verifica o limite
    if len(equipped_skills) >= MAX_EQUIPPED_SKILLS:
        await query.answer(f"Limite de {MAX_EQUIPPED_SKILLS} skills equipadas atingido!", show_alert=True)
        # Atualiza o menu para mostrar o bot√£o de limite
        await show_equip_skills_menu(update, context)
        return

    # Equipa a skill
    equipped_skills.append(skill_id)
    await player_manager.save_player_data(user_id, player_data)

    # logger.info(f"Jogador {user_id} equipou a skill: {skill_id}") # Log opcional
    # Atualiza a mensagem mostrando o novo estado
    await show_equip_skills_menu(update, context)


async def unequip_skill_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Desequipa uma skill ativa."""
    query = update.callback_query
    await query.answer() # Responde ao clique
    user_id = query.from_user.id

    try:
        # Extrai o ID da skill do callback_data (formato: "unequip_skill:skill_id")
        skill_id = query.data.split(":", 1)[1]
    except IndexError:
        logger.error(f"Callback unequip_skill inv√°lido: {query.data}")
        await query.answer("Erro ao processar a a√ß√£o.", show_alert=True)
        return

    player_data = await player_manager.get_player_data(user_id)
    if not player_data:
        await query.answer("Erro: Personagem n√£o encontrado.", show_alert=True)
        return

    equipped_skills = player_data.get("equipped_skills", [])
    if not isinstance(equipped_skills, list): # Seguran√ßa
        equipped_skills = []
        player_data["equipped_skills"] = equipped_skills


    # Verifica se a skill est√° realmente equipada antes de remover
    if skill_id in equipped_skills:
        equipped_skills.remove(skill_id)
        await player_manager.save_player_data(user_id, player_data)
        # logger.info(f"Jogador {user_id} desequipou a skill: {skill_id}") # Log opcional
    else:
        await query.answer("Essa skill n√£o estava equipada.", show_alert=True)


    # Atualiza a mensagem mostrando o novo estado
    await show_equip_skills_menu(update, context)

async def noop_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Callback que n√£o faz nada, usado para bot√µes desativados como 'Limite Atingido'."""
    query = update.callback_query
    # Apenas responde ao clique para o Telegram saber que foi recebido
    await query.answer("Limite de skills equipadas atingido!")

async def _safe_edit_or_send(query, context, chat_id, text, reply_markup=None, parse_mode='HTML'):
    try:
        await query.edit_message_caption(caption=text, reply_markup=reply_markup, parse_mode=parse_mode); return
    except Exception:
        pass
    try:
        await query.edit_message_text(text=text, reply_markup=reply_markup, parse_mode=parse_mode); return
    except Exception:
        pass
    await context.bot.send_message(chat_id=chat_id, text=text, reply_markup=reply_markup, parse_mode=parse_mode)

def _bar(current: int, total: int, blocks: int = 10, filled_char: str = 'üüß', empty_char: str = '‚¨úÔ∏è') -> str:
    if total <= 0:
        filled = blocks
    else:
        ratio = max(0.0, min(1.0, float(current) / float(total)))
        filled = int(round(ratio * blocks))
    return filled_char * filled + empty_char * (blocks - filled)

def _normalize_profession(raw):
    if not raw:
        return None
    if isinstance(raw, str):
        return (raw, 1, 0)
    if isinstance(raw, dict) and ('type' in raw):
        t = raw.get('type') or None
        if not t: return None
        return (t, int(raw.get('level', 1)), int(raw.get('xp', 0)))
    if isinstance(raw, dict):
        for k, v in raw.items():
            if isinstance(v, dict):
                return (k, int(v.get('level', 1)), int(v.get('xp', 0)))
            return (k, 1, 0)
    return None

def _class_key_from_player(player_data: dict) -> str:
    if player_data.get("class_key"):
        return str(player_data["class_key"])
    raw = (player_data.get("class") or "").strip()
    return _slugify(raw) or "_default"

def _durability_tuple(raw) -> tuple[int, int]:
    """Converte a durabilidade (lista, ditado ou None) para uma tupla (atual, max)."""
    cur, mx = 20, 20
    if isinstance(raw, (list, tuple)) and len(raw) >= 2:
        try:
            cur = int(raw[0]); mx = int(raw[1])
        except Exception:
            cur, mx = 20, 20
    elif isinstance(raw, dict):
        try:
            cur = int(raw.get("current", 20)); mx = int(raw.get("max", 20))
        except Exception:
            cur, mx = 20, 20
    # Garante que os valores s√£o v√°lidos
    mx = max(1, mx) # Max n√£o pode ser 0
    cur = max(0, min(cur, mx)) # Atual n√£o pode ser negativo ou maior que o max
    return cur, mx

async def show_restore_durability_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()

    user_id = q.from_user.id
    chat_id = q.message.chat_id
    pdata = await player_manager.get_player_data(user_id) or {}
    inv = pdata.get("inventory", {}) or {}
    equip = pdata.get("equipment", {}) or {}

    lines = ["<b>üìú Restaurar Durabilidade</b>\nEscolha um item <u>equipado</u> para restaurar:\n"]
    kb_rows = []
    any_repairable = False

    for slot, uid in (equip.items() if isinstance(equip, dict) else []):
        inst = inv.get(uid)
        if not (isinstance(inst, dict) and inst.get("base_id")):
            continue
        cur, mx = _durability_tuple(inst.get("durability")) # <-- Agora _durability_tuple existe
        if cur < mx:
            any_repairable = True
            base = (getattr(game_data, "ITEMS_DATA", {}) or {}).get(inst["base_id"], {}) or {}
            name = base.get("display_name", inst["base_id"])
            lines.append(f"‚Ä¢ {name} ‚Äî <b>{cur}/{mx}</b>")
            kb_rows.append([InlineKeyboardButton(f"Restaurar {name}", callback_data=f"rd_fix_{uid}")])

    if not any_repairable:
        lines.append("<i>Nenhum equipamento equipado precisa de reparo.</i>")

    kb_rows.append([InlineKeyboardButton("‚¨ÖÔ∏è ùïçùï†ùïùùï•ùïíùï£", callback_data="profile")])

    try:
        await q.edit_message_caption(caption="\n".join(lines), reply_markup=InlineKeyboardMarkup(kb_rows), parse_mode="HTML")
    except Exception:
        try:
             await q.edit_message_text(text="\n".join(lines), reply_markup=InlineKeyboardMarkup(kb_rows), parse_mode="HTML")
        except Exception as e:
             logger.warning(f"Falha ao editar menu de durabilidade: {e}")
             await context.bot.send_message(chat_id=chat_id, text="\n".join(lines), reply_markup=InlineKeyboardMarkup(kb_rows), parse_mode="HTML")

async def fix_item_durability(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()

    user_id = q.from_user.id
    pdata = await player_manager.get_player_data(user_id) or {} 
    uid = q.data.replace("rd_fix_", "", 1)

    from modules.profession_engine import restore_durability as restore_durability_engine

    res = restore_durability_engine(pdata, uid)
    if isinstance(res, dict) and res.get("error"):
        await q.answer(res["error"], show_alert=True)
        await show_restore_durability_menu(update, context) # <-- Agora show_restore_durability_menu existe
        return

    await player_manager.save_player_data(user_id, pdata)

    await q.answer("Durabilidade restaurada!", show_alert=True)
    await show_restore_durability_menu(update, context) # <-- Agora show_restore_durability_menu existe

async def fix_item_durability(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()

    user_id = q.from_user.id
    # <<< CORRE√á√ÉO 3: Adiciona await >>>
    pdata = await player_manager.get_player_data(user_id) or {} 
    uid = q.data.replace("rd_fix_", "", 1)

    # usamos o engine oficial para reparar (consome pergaminho)
    from modules.profession_engine import restore_durability as restore_durability_engine

    res = restore_durability_engine(pdata, uid) # S√≠ncrono
    if isinstance(res, dict) and res.get("error"):
        await q.answer(res["error"], show_alert=True)
        # volta/atualiza a listagem
        # <<< CORRE√á√ÉO 4: Adiciona await >>>
        await show_restore_durability_menu(update, context) # Chama fun√ß√£o async
        return

    # <<< CORRE√á√ÉO 5: Adiciona await >>>
    await player_manager.save_player_data(user_id, pdata)

    # feedback leve e atualiza a lista
    await q.answer("Durabilidade restaurada!", show_alert=True)
    # <<< CORRE√á√ÉO 6: Adiciona await >>>
    await show_restore_durability_menu(update, context) # Chama fun√ß√£o async
    
#
# >>> COLE ESTA FUN√á√ÉO COMPLETA NO LUGAR DA SUA "profile_callback" ANTIGA <<<
# (handlers/profile_handler.py)
#

async def profile_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # --- NOVA CORRE√á√ÉO (In√≠cio) ---
    # L√≥gica para lidar com COMANDO ou BOT√ÉO
    query = update.callback_query
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id

    if not chat_id:
         logger.warning("profile_callback n√£o conseguiu determinar o chat_id.")
         return

    if query:
        await query.answer()
    # --- NOVA CORRE√á√ÉO (Fim) ---
        
    # Carrega os dados do jogador (J√° estava correto com await)
    player_data = await player_manager.get_player_data(user_id)

    if not player_data:
        # --- NOVA CORRE√á√ÉO: Usa o 'update' e n√£o o 'query' para o _safe_edit_or_send ---
        await _safe_edit_or_send_v2(update, context, chat_id, "Erro: Personagem n√£o encontrado. Use /start para come√ßar.")
        return
    
    # ===== totais (base + equipamentos) =====
    
    # <<< CORRE√á√ÉO 1: Adiciona await AQUI >>>
    totals = await player_manager.get_player_total_stats(player_data)
    
    # Agora 'totals' √© um dicion√°rio e .get() vai funcionar
    total_hp_max = int(totals.get('max_hp', 50))
    total_atk = int(totals.get('attack', 0))
    total_def = int(totals.get('defense', 0))
    total_ini = int(totals.get('initiative', 0))
    total_luck = int(totals.get('luck', 0))

    current_hp = max(0, min(int(player_data.get('current_hp', total_hp_max)), total_hp_max))
    
    # <<< CORRE√á√ÉO 2 & 3: Adiciona await AQUI TAMB√âM >>>
    chance_esquiva = int((await player_manager.get_player_dodge_chance(player_data)) * 100)
    chance_ataque_duplo = int((await player_manager.get_player_double_attack_chance(player_data)) * 100)

    location_key = player_data.get('current_location', 'reino_eldora')
    location_name = (game_data.REGIONS_DATA or {}).get(location_key, {}).get('display_name', 'Lugar Desconhecido')

    # =================================================================
    # ===== BLOCO PREMIUM (J√° estava correto) =====
    # =================================================================
    premium_line = ""
    premium = PremiumManager(player_data) # Instancia o manager
    if premium.is_premium(): # Usa o m√©todo correto para verificar
        tier_name = premium.tier.capitalize() if premium.tier else "Premium"
        exp_date = premium.expiration_date
        
        premium_line = f"\nüëë <b>Status Premium:</b> {tier_name}"
        if exp_date:
            premium_line += f"\n(Expira em: {exp_date.strftime('%d/%m/%Y')})"
        else:
            premium_line += " (Permanente)"
    
    # (Resto da l√≥gica de XP, Profiss√£o, Classe - mantida igual)
    max_energy  = int(player_manager.get_player_max_energy(player_data))
    combat_level = int(player_data.get('level', 1))
    combat_xp = int(player_data.get('xp', 0))
    try:
        combat_next = int(game_data.get_xp_for_next_combat_level(combat_level))
    except Exception:
        combat_next = 0
    combat_bar = _bar(combat_xp, combat_next)

    prof_line = "" 
    prof_norm = _normalize_profession(player_data.get('profession'))
    if prof_norm:
        prof_key, prof_level, prof_xp = prof_norm
        prof_name = (game_data.PROFESSIONS_DATA or {}).get(prof_key, {}).get('display_name', prof_key)
        try:
            prof_next = int(game_data.get_xp_for_next_collection_level(prof_level))
        except Exception:
            prof_next = 0
        prof_bar = _bar(prof_xp, prof_next, blocks=10, filled_char='üü®', empty_char='‚¨úÔ∏è')
        prof_line = f"\nüíº <b>Profiss√£o:</b> {prof_name} ‚Äî N√≠vel {prof_level}\n<code>[{prof_bar}]</code> {prof_xp}/{prof_next} XP"
    
    class_banner = ""
    if player_manager.needs_class_choice(player_data):
        class_banner = "\n\n‚ú® <b>Escolha sua Classe!</b>"

    current_class_key = (player_data.get("class") or "no_class").lower()
    class_config = (game_data.CLASSES_DATA or {}).get(current_class_key, {})
    class_name = class_config.get("display_name", current_class_key.title())
    class_emoji = class_config.get("emoji", "üë§")

    # ===== texto do perfil =====
    char_name = player_data.get('character_name','Aventureiro(a)')
    available_points = int(player_data.get("stat_points", 0) or 0)

    lines = [
        f"üë§ <b>P·¥á Ä“ì…™ ü ·¥Ö·¥á {char_name}</b>{premium_line}",
        f"{class_emoji} <b>Classe:</b> {class_name}", 
        f"üìç <b>ùë≥ùíêùíÑùíÇùíçùíäùíõùíÇùíÑÃßùíÇÃÉùíê ùë®ùíïùíñùíÇùíç:</b> {location_name}",
        "",
        f"‚ù§Ô∏è <b>ùêáùêè:</b> {current_hp} / {total_hp_max}",
        f"‚ö°Ô∏è <b>ùêÑùêßùêûùê´ùê†ùê¢ùêö:</b> {int(player_data.get('energy', 0))} / {max_energy}",
        "",
        f"üß° <b>ùêáùêè ùêåùêöÃÅùê±ùê¢ùê¶ùê®:</b> {total_hp_max}",
        f"‚öîÔ∏è <b>ùêÄùê≠ùêöùê™ùêÆùêû:</b> {total_atk}",
        f"üõ°Ô∏è <b>ùêÉùêûùêüùêûùê¨ùêö:</b> {total_def}",
        f"üèÉ <b>ùêàùêßùê¢ùêúùê¢ùêöùê≠ùê¢ùêØùêö:</b> {total_ini}",
        f"üçÄ <b>ùêíùê®ùê´ùê≠ùêû:</b> {total_luck}",
        f"‚ö°Ô∏è <b>Chance de Esquiva:</b> {chance_esquiva}%",
        f"‚öîÔ∏è <b>Chance de Ataque Duplo:</b> {chance_ataque_duplo}%",
        "",
        f"üéØ <b>ùë∑ùíêùíèùíïùíêùíî ùíÖùíÜ ùë®ùíïùíìùíäùíÉùíñùíïùíê ùíÖùíäùíîùíëùíêùíèùíäÃÅùíóùíÜùíäùíî:</b> {available_points}",
        f"üéñÔ∏è <b>ùëµùíäÃÅùíóùíÜùíç ùíÖùíÜ ùë™ùíêùíéùíÉùíÇùíïùíÜ:</b> {combat_level}\n<code>[{combat_bar}]</code> {combat_xp}/{combat_next} ùêóùêè",
    ]
    if prof_line:
        lines.append(prof_line)
    if class_banner:
        lines.append(class_banner)

    profile_text = "\n".join(lines)

    # ===== teclado (Mantido igual) =====
    keyboard = []
    if player_manager.needs_class_choice(player_data):
        keyboard.append([InlineKeyboardButton("‚ú® ùêÑùê¨ùêúùê®ùê•ùê°ùêûùê´ ùêÇùê•ùêöùê¨ùê¨ùêû", callback_data='class_open')])
    if not prof_norm:
        keyboard.append([InlineKeyboardButton("üíº ùêÑùê¨ùêúùê®ùê•ùê°ùêûùê´ ùêèùê´ùê®ùêüùê¢ùê¨ùê¨ùêöÃÉùê®", callback_data='job_menu')])

    keyboard.extend([
        [InlineKeyboardButton("üî∞ ¬†ùêÇùê•ùêön ¬†üî∞", callback_data='clan_menu:profile')],
        [InlineKeyboardButton("üìä ùêíùê≠ùêöùê≠ùêÆùê¨ & ùêÄùê≠ùê´ùê¢ùêõùêÆùê≠ùê®ùê¨", callback_data='status_open')],
        [InlineKeyboardButton("üß∞ ùêÑùê™ùêÆùê¢ùê©ùêöùê¶ùêûùêßùê≠ùê®ùê¨", callback_data='equipment_menu')],
        [InlineKeyboardButton("üéí ùêïùêûùê´ ùêàùêßùêØùêûùêßùê≠ùêöÃÅùê´ùê¢ùê® ùêÇùê®ùê¶ùê©ùê•ùêûto", callback_data='inventory_CAT_equipamento_PAGE_1')],
        [InlineKeyboardButton("üß™ ùêîùê¨ùêöùê´ ùêÇùê®ùêßùê¨ùêÆùê¶ùê¢ÃÅùêØùêûùê•", callback_data='potion_menu')],
        [InlineKeyboardButton("üìö ùêáùêöùêõùê¢ùê•ùê¢ùêùùêöùêùùêûùê¨", callback_data='skills_menu_open')],
        [InlineKeyboardButton("üé® ùêåùêÆùêùùêöùê´ ùêÄùê©ùêöùê´ùêûÃÇùêßùêúùê¢ùêö", callback_data='skin_menu')],
        [InlineKeyboardButton("‚¨ÖÔ∏è ùêïùê®ùê•ùê≠ùêöùê´", callback_data='continue_after_action')],
    ])
    reply_markup = InlineKeyboardMarkup(keyboard)

    # ===== m√≠dia da classe (Mantido igual) =====
    media = _get_class_media(player_data, "personagem")
    if media and media.get("id"):
        try:
            # --- NOVA CORRE√á√ÉO: Apenas apaga se for um bot√£o ---
            if query: 
                await query.delete_message()
                
            fid  = media["id"]
            ftyp = (media.get("type") or "photo").lower()
            if ftyp == "video":
                await context.bot.send_video(chat_id=chat_id, video=fid, caption=profile_text, reply_markup=reply_markup, parse_mode="HTML")
            else:
                await context.bot.send_photo(chat_id=chat_id, photo=fid, caption=profile_text, reply_markup=reply_markup, parse_mode="HTML")
            return 
        except Exception as e:
            logger.error(f"Falha ao enviar m√≠dia do perfil para user {user_id}: {e}")

    # Fallback: sem m√≠dia (Mantido igual)
    # --- NOVA CORRE√á√ÉO: Passa 'update' em vez de 'query' ---
    await _safe_edit_or_send_v2(update, context, chat_id, profile_text, reply_markup=reply_markup, parse_mode='HTML')


# --- NOVA FUN√á√ÉO HELPER (Necess√°ria para a corre√ß√£o) ---
# (Pode apagar a sua `_safe_edit_or_send` antiga e usar esta)
async def _safe_edit_or_send_v2(update: Update, context: ContextTypes.DEFAULT_TYPE, chat_id: int, text: str, reply_markup=None, parse_mode='HTML'):
    """
    Tenta editar a mensagem se for um CallbackQuery.
    Se falhar, ou se for um Comando, envia uma nova mensagem.
    """
    query = update.callback_query
    if query:
        try:
            await query.edit_message_caption(caption=text, reply_markup=reply_markup, parse_mode=parse_mode)
            return
        except BadRequest as e:
            if "message is not modified" not in str(e).lower():
                pass # Tenta editar como texto
        except Exception:
            pass # Tenta editar como texto
        
        try:
            await query.edit_message_text(text=text, reply_markup=reply_markup, parse_mode=parse_mode)
            return
        except BadRequest as e:
            if "message is not modified" not in str(e).lower():
                logger.debug(f"_safe_edit_or_send_v2: Falha ao editar texto: {e}")
        except Exception as e:
            logger.debug(f"_safe_edit_or_send_v2: Falha ao editar texto: {e}")

    # Fallback: Se for comando ou se a edi√ß√£o falhar
    try:
        await context.bot.send_message(chat_id=chat_id, text=text, reply_markup=reply_markup, parse_mode=parse_mode)
    except Exception as e:
        logger.error(f"_safe_edit_or_send_v2: Falha ao enviar nova mensagem: {e}")

profile_handler = CallbackQueryHandler(profile_callback, pattern=r'^(?:profile|personagem|char_sheet_main)$') # Callback para bot√µes como "Voltar ao Perfil"
character_command_handler = CommandHandler("personagem", profile_callback)



# Handlers de Skills
skills_menu_handler = CallbackQueryHandler(show_skills_menu, pattern=r"^skills_menu_open$")
skills_equip_menu_handler = CallbackQueryHandler(show_equip_skills_menu, pattern=r"^skills_equip_menu$")
equip_skill_handler = CallbackQueryHandler(equip_skill_callback, pattern=r"^equip_skill:")
unequip_skill_handler = CallbackQueryHandler(unequip_skill_callback, pattern=r"^unequip_skill:")
noop_handler = CallbackQueryHandler(noop_callback, pattern=r"^noop$")

